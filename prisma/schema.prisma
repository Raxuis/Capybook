// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

// Looking for ways to speed up your queries, or scale easily with your serverless or edge functions?
// Try Prisma Accelerate: https://pris.ly/cli/accelerate-init

generator client {
  provider        = "prisma-client-js"
  previewFeatures = ["driverAdapters"]
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id            String    @id @default(cuid())
  email         String    @unique
  username      String    @unique
  name          String?
  password      String? // Keeping for credentials-based login
  emailVerified DateTime?
  image         String?
  favoriteColor String    @default("#3b82f6")
  role          Role      @default(USER) // USER, ADMIN, MODERATOR
  accounts      Account[]
  sessions      Session[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  UserBook         UserBook[]
  BookReview       BookReview[]
  UserBookWishlist UserBookWishlist[]
  ReadingGoal      ReadingGoal[]
  UserBadge        UserBadge[]
  ReadingProgress  ReadingProgress[]
  ReadingDay       ReadingDay[]

  followers Follow[] @relation("following")
  following Follow[] @relation("followers")

  // New relation for specific friend reviews
  specificFriendReviews BookReview[]    @relation("SpecificFriendReviews")
  UserBookNotes         UserBookNotes[]
}

model Account {
  userId            String
  type              String
  provider          String
  providerAccountId String
  refresh_token     String?
  access_token      String?
  expires_at        Int?
  token_type        String?
  scope             String?
  id_token          String?
  session_state     String?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@id([provider, providerAccountId])
}

model Session {
  sessionToken String   @unique
  userId       String
  expires      DateTime
  user         User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

model VerificationToken {
  identifier String
  token      String
  expires    DateTime

  @@id([identifier, token])
}

model UserBook {
  id            String    @id @default(cuid())
  userId        String
  bookId        String
  isCurrentBook Boolean   @default(false)
  progressType  String?   @default("percentage")
  progress      Int       @default(0)
  createdAt     DateTime  @default(now())
  updatedAt     DateTime  @updatedAt
  finishedAt    DateTime?
  User          User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  Book          Book      @relation(fields: [bookId], references: [id], onDelete: Cascade)

  @@unique([userId, bookId])
}

model UserBookNotes {
  id        String   @id @default(cuid())
  userId    String
  bookId    String
  note      String
  page      Int?
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  User      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  Book      Book     @relation(fields: [bookId], references: [id], onDelete: Cascade)

  // Aucun @@unique ici pour permettre plusieurs notes par livre
}

model UserBookWishlist {
  id        String   @id @default(cuid())
  userId    String
  bookId    String
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  User      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  Book      Book     @relation(fields: [bookId], references: [id], onDelete: Cascade)

  @@unique([userId, bookId])
}

model Book {
  id               String             @id @default(cuid())
  key              String             @unique
  title            String
  authors          String[]
  cover            String?
  numberOfPages    Int?
  createdAt        DateTime           @default(now())
  updatedAt        DateTime           @updatedAt
  UserBook         UserBook[]
  BookReview       BookReview[]
  UserBookWishlist UserBookWishlist[]
  BookGenre        BookGenre[]
  UserBookNotes    UserBookNotes[]
}

model BookReview {
  id               String   @id @default(cuid())
  userId           String
  bookId           String
  rating           Int?
  feedback         String?
  privacy          Privacy  @default(PUBLIC) // "PUBLIC", "PRIVATE", "FRIENDS", "SPECIFIC_FRIEND"
  privateLink      String?  @unique // For PRIVATE reviews
  specificFriendId String? // For SPECIFIC_FRIEND reviews
  createdAt        DateTime @default(now())
  updatedAt        DateTime @updatedAt
  User             User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  Book             Book     @relation(fields: [bookId], references: [id], onDelete: Cascade)
  SpecificFriend   User?    @relation("SpecificFriendReviews", fields: [specificFriendId], references: [id], onDelete: SetNull)

  @@unique([userId, bookId])
}

model ReadingGoal {
  id          String    @id @default(cuid())
  userId      String
  target      Int // Nombre de livres ou pages à lire
  type        GoalType // "BOOKS" ou "PAGES" ou "TIME"
  deadline    DateTime // Date limite pour l'objectif
  progress    Int       @default(0) // Avancement de l'utilisateur
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt
  completedAt DateTime?
  User        User      @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model Badge {
  id                String        @id @default(cuid())
  name              String        @unique
  ownerDescription  String
  publicDescription String
  category          BadgeCategory
  requirement       Int // Nombre requis pour obtenir le badge (ex: 10 livres)
  icon              String? // Chemin ou identifiant de l'icône du badge
  createdAt         DateTime      @default(now())
  updatedAt         DateTime      @updatedAt
  UserBadge         UserBadge[]
}

model UserBadge {
  id       String   @id @default(cuid())
  userId   String
  badgeId  String
  earnedAt DateTime @default(now())
  User     User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  Badge    Badge    @relation(fields: [badgeId], references: [id], onDelete: Cascade)

  @@unique([userId, badgeId]) // Un utilisateur ne peut avoir un type de badge qu'une seule fois
}

enum Role {
  USER
  ADMIN
  MODERATOR
}

enum GoalType {
  BOOKS
  PAGES
  TIME
}

enum BadgeCategory {
  BOOKS_READ // Nombre de livres lus
  PAGES_READ // Nombre de pages lues
  REVIEWS_WRITTEN // Nombre de critiques écrites
  GOALS_COMPLETED // Nombre d'objectifs atteints
  READING_STREAK // Jours consécutifs de lecture
  GENRE_EXPLORER // Diversité des genres lus
  SPECIAL // Badges spéciaux ou événementiels
}

enum Privacy {
  PUBLIC
  PRIVATE
  FRIENDS
  SPECIFIC_FRIEND
}

model ReadingProgress {
  id             String     @id @default(cuid())
  userId         String
  readingDayId   String     @unique // Assure qu'un seul progrès par ReadingDay
  date           DateTime
  pagesRead      Int
  booksCompleted Int
  user           User       @relation(fields: [userId], references: [id], onDelete: Cascade)
  readingDay     ReadingDay @relation(fields: [readingDayId], references: [id])
}

model ReadingDay {
  id              String           @id @default(cuid())
  userId          String
  date            DateTime         @default(now()) @db.Date
  minutesRead     Int              @default(0)
  pagesRead       Int              @default(0)
  user            User             @relation(fields: [userId], references: [id], onDelete: Cascade)
  readingProgress ReadingProgress?

  @@unique([userId, date])
}

model Genre {
  id        String      @id @default(cuid())
  name      String      @unique
  createdAt DateTime    @default(now())
  updatedAt DateTime    @updatedAt
  books     BookGenre[]
}

model BookGenre {
  id        String   @id @default(cuid())
  bookId    String
  genreId   String
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  book      Book     @relation(fields: [bookId], references: [id], onDelete: Cascade)
  genre     Genre    @relation(fields: [genreId], references: [id], onDelete: Cascade)

  @@unique([bookId, genreId])
}

model Follow {
  id          String   @id @default(cuid())
  followerId  String // The user who follows
  followingId String // The user being followed
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  follower  User @relation("followers", fields: [followerId], references: [id], onDelete: Cascade)
  following User @relation("following", fields: [followingId], references: [id], onDelete: Cascade)

  @@unique([followerId, followingId]) // Prevents duplicate follows
}
